const PDFDocument = require('pdfkit');
const HealthReport = require('../models/HealthReport');

const toArray = (value) => {
  if (Array.isArray(value)) {
    return value.map((item) => (typeof item === 'string' ? item.trim() : item)).filter((item) => item !== undefined && item !== null && item !== '');
  }
  if (typeof value === 'string') {
    return value
      .split(',')
      .map((item) => item.trim())
      .filter((item) => item !== '');
  }
  if (value !== undefined && value !== null && value !== '') {
    return [value];
  }
  return [];
};

exports.exportReportPdf = async (req, res) => {
  try {
    const report = await HealthReport.findById(req.params.id).lean();
    if (!report) {
      return res.status(404).json({ message: 'Report not found' });
    }

    const fileName = `${sanitizeFileName(report.title)}.pdf`;
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);

    const doc = new PDFDocument({ margin: 50 });
    doc.pipe(res);

    doc.fontSize(20).text(report.title || 'Health Report', { align: 'center' });
    doc.moveDown();
    doc.fontSize(12);

    const detailLines = [
      ['Report Type', report.reportType || ''],
      ['Category', report.category || ''],
      ['Status', report.status || ''],
      ['Generated By', report.generatedBy || 'Health Officer'],
      ['Generated On', toIsoDate(report.generatedAt)],
      ['Date Range Start', toIsoDate(report?.dateRange?.start)],
      ['Date Range End', toIsoDate(report?.dateRange?.end)],
      ['Schedule', report?.schedule?.enabled ? report.schedule.frequency || 'scheduled' : 'Manual'],
      ['Recipients', Array.isArray(report?.schedule?.recipients) ? report.schedule.recipients.join(', ') : '']
    ];

    detailLines.forEach(([label, value]) => {
      doc.font('Helvetica-Bold').text(`${label}: `, { continued: true });
      doc.font('Helvetica').text(value || '—');
    });

    if (report.description) {
      doc.moveDown();
      doc.font('Helvetica-Bold').text('Description:');
      doc.font('Helvetica').text(report.description, { paragraphGap: 6 });
    }

    if (Array.isArray(report.sections) && report.sections.length) {
      doc.moveDown();
      doc.font('Helvetica-Bold').text('Sections Included:');
      doc.font('Helvetica').text(report.sections.join(', '));
    }

    if (Array.isArray(report.tags) && report.tags.length) {
      doc.moveDown();
      doc.font('Helvetica-Bold').text('Tags:');
      doc.font('Helvetica').text(report.tags.join(', '));
    }

    if (Array.isArray(report.metrics) && report.metrics.length) {
      doc.moveDown();
      doc.font('Helvetica-Bold').text('Key Metrics:');
      doc.moveDown(0.5);

      report.metrics.forEach((metric, index) => {
        const title = metric?.name || `Metric ${index + 1}`;
        doc.font('Helvetica-Bold').text(title);
        doc.font('Helvetica').text(
          `Current: ${metric?.currentValue ?? '—'}${metric?.unit || ''} | Previous: ${metric?.previousValue ?? '—'}${metric?.unit || ''} | Target: ${metric?.target ?? '—'}${metric?.unit || ''}`
        );
        doc.font('Helvetica').text(`Trend: ${metric?.trend ?? '—'} | Status: ${metric?.status || '—'}`);
        if (metric?.notes) {
          doc.font('Helvetica').text(`Notes: ${metric.notes}`);
        }
        doc.moveDown(0.5);
      });
    }

    if (report?.certificateInfo) {
      doc.moveDown();
      doc.font('Helvetica-Bold').text('Certificate Information:');
      doc.font('Helvetica').text(
        `Crew Member: ${report.certificateInfo.crewMember || '—'} | Type: ${report.certificateInfo.certificateType || '—'}`
      );
      doc.font('Helvetica').text(
        `Issue Date: ${toIsoDate(report.certificateInfo.issueDate)} | Expiry Date: ${toIsoDate(report.certificateInfo.expiryDate)} | Status: ${report.certificateInfo.status || '—'}`
      );
    }

    if (Array.isArray(report.files) && report.files.length) {
      doc.moveDown();
      doc.font('Helvetica-Bold').text('Files:');
      report.files.forEach((file) => {
        doc.font('Helvetica').text(`${file?.label || 'Attachment'} - ${file?.url || ''}`);
      });
    }

    doc.end();
  } catch (error) {
    console.error('exportReportPdf error', error);
    return res.status(500).json({ message: 'Failed to export report as PDF' });
  }
};

exports.exportReportCsv = async (req, res) => {
  try {
    const report = await HealthReport.findById(req.params.id).lean();
    if (!report) {
      return res.status(404).json({ message: 'Report not found' });
    }

    const rows = [
      ['Title', report.title || ''],
      ['Report Type', report.reportType || ''],
      ['Category', report.category || ''],
      ['Status', report.status || ''],
      ['Generated By', report.generatedBy || 'Health Officer'],
      ['Generated On', toIsoDate(report.generatedAt)],
      ['Date Range Start', toIsoDate(report?.dateRange?.start)],
      ['Date Range End', toIsoDate(report?.dateRange?.end)],
      ['Schedule Enabled', report?.schedule?.enabled ? 'Yes' : 'No'],
      ['Schedule Frequency', report?.schedule?.frequency || ''],
      ['Schedule Next Run', toIsoDate(report?.schedule?.nextRunAt)],
      ['Recipients', Array.isArray(report?.schedule?.recipients) ? report.schedule.recipients.join('; ') : ''],
      ['Sections', Array.isArray(report.sections) ? report.sections.join('; ') : ''],
      ['Tags', Array.isArray(report.tags) ? report.tags.join('; ') : ''],
      ['Description', report.description || ''],
      ['File Size (bytes)', report.fileSize || '']
    ];

    const lines = rows.map((row) => row.map((cell) => escapeCsv(cell)).join(','));

    if (Array.isArray(report.metrics) && report.metrics.length) {
      lines.push('');
      lines.push(['Metric Name', 'Current Value', 'Previous Value', 'Target', 'Trend', 'Unit', 'Status', 'Notes'].map(escapeCsv).join(','));
      report.metrics.forEach((metric) => {
        const metricRow = [
          metric?.name || '',
          metric?.currentValue ?? '',
          metric?.previousValue ?? '',
          metric?.target ?? '',
          metric?.trend ?? '',
          metric?.unit || '',
          metric?.status || '',
          metric?.notes || ''
        ];
        lines.push(metricRow.map(escapeCsv).join(','));
      });
    }

    if (Array.isArray(report.files) && report.files.length) {
      lines.push('');
      lines.push(['File Label', 'File URL'].map(escapeCsv).join(','));
      report.files.forEach((file) => {
        lines.push([file?.label || '', file?.url || ''].map(escapeCsv).join(','));
      });
    }

    const csvContent = lines.join('\n');
    const fileName = `${sanitizeFileName(report.title)}.csv`;
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
    return res.send(csvContent);
  } catch (error) {
    console.error('exportReportCsv error', error);
    return res.status(500).json({ message: 'Failed to export report as CSV' });
  }
};

const toNumber = (value) => {
  if (value === undefined || value === null || value === '') {
    return undefined;
  }
  const num = Number(value);
  return Number.isNaN(num) ? undefined : num;
};

const toDate = (value) => {
  if (!value) {
    return undefined;
  }
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return undefined;
  }
  return date;
};

const normalizeMetrics = (metrics) => {
  if (!Array.isArray(metrics)) {
    return [];
  }
  return metrics
    .map((metric) => ({
      name: metric?.name,
      currentValue: toNumber(metric?.currentValue),
      unit: metric?.unit || '%',
      previousValue: toNumber(metric?.previousValue),
      target: toNumber(metric?.target),
      trend: toNumber(metric?.trend),
      status: metric?.status || 'info',
      notes: metric?.notes || ''
    }))
    .filter((metric) => metric.name);
};

const normalizeFiles = (files) => {
  if (!Array.isArray(files)) {
    return [];
  }
  return files
    .map((file) => ({
      label: file?.label,
      url: file?.url
    }))
    .filter((file) => file.label && file.url);
};

const normalizeCertificate = (body) => {
  const source = body.certificateInfo || {};
  const crewMember = source.crewMember || body.certificateCrewMember;
  const certificateType = source.certificateType || body.certificateType;
  const issueDate = source.issueDate || body.certificateIssueDate;
  const expiryDate = source.expiryDate || body.certificateExpiryDate;
  const status = source.status || body.certificateStatus;
  if (!crewMember && !certificateType && !issueDate) {
    return undefined;
  }
  return {
    crewMember: crewMember || '',
    certificateType: certificateType || 'General Certificate',
    issueDate: toDate(issueDate) || new Date(),
    expiryDate: toDate(expiryDate),
    status: status || 'valid'
  };
};

const normalizeSchedule = (body) => {
  const source = body.schedule || {};
  const enabledInput = source.enabled !== undefined ? source.enabled : body.scheduleEnabled;
  const enabled = enabledInput === undefined ? false : Boolean(enabledInput);
  if (!enabled) {
    return { enabled: false };
  }
  const frequency = source.frequency || body.scheduleFrequency || 'monthly';
  const nextRunAt = source.nextRunAt || body.scheduleNextRunAt;
  const recipients = source.recipients || body.scheduleRecipients;
  return {
    enabled: true,
    frequency,
    nextRunAt: toDate(nextRunAt),
    recipients: toArray(recipients)
  };
};

const buildDateRange = (body) => {
  const startInput = body.startDate || body.dateRange?.start;
  const endInput = body.endDate || body.dateRange?.end;
  const start = toDate(startInput);
  const end = toDate(endInput) || start;
  if (!start || !end) {
    return undefined;
  }
  return { start, end };
};

const buildPayload = (body, user) => {
  const payload = {
    category: body.category || 'summary',
    reportType: body.reportType,
    title: body.title,
    description: body.description || '',
    status: body.status || 'completed',
    generatedBy: body.generatedBy || user?.fullName || 'Health Officer',
    sections: toArray(body.sections),
    formats: toArray(body.formats).length ? toArray(body.formats) : ['pdf'],
    fileSize: toNumber(body.fileSize),
    tags: toArray(body.tags),
    metrics: normalizeMetrics(body.metrics),
    files: normalizeFiles(body.files)
  };
  const dateRange = buildDateRange(body);
  if (dateRange) {
    payload.dateRange = dateRange;
  }
  if (body.generatedAt) {
    const generatedAt = toDate(body.generatedAt);
    if (generatedAt) {
      payload.generatedAt = generatedAt;
    }
  }
  const certificateInfo = normalizeCertificate(body);
  if (certificateInfo) {
    payload.certificateInfo = certificateInfo;
  }
  const schedule = normalizeSchedule(body);
  if (schedule) {
    payload.schedule = schedule;
  }
  return payload;
};

const sanitizeFileName = (value, fallback = 'health-report') => {
  const source = (value || fallback).toString().toLowerCase();
  const sanitized = source.replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
  return sanitized || fallback;
};

const toIsoDate = (value) => {
  if (!value) return '';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return '';
  }
  return date.toISOString().split('T')[0];
};

const escapeCsv = (value) => {
  if (value === undefined || value === null) {
    return '""';
  }
  const stringValue = String(value).replace(/"/g, '""');
  return `"${stringValue}"`;
};

exports.createReport = async (req, res) => {
  try {
    const payload = buildPayload(req.body || {}, req.user);
    if (!payload.reportType || !payload.title) {
      return res.status(400).json({ message: 'Report type and title are required' });
    }
    if (!payload.dateRange) {
      return res.status(400).json({ message: 'Start and end dates are required' });
    }
    payload.createdBy = req.user?.id || null;
    payload.updatedBy = req.user?.id || null;
    const report = await HealthReport.create(payload);
    return res.status(201).json(report);
  } catch (error) {
    console.error('createReport error', error);
    return res.status(500).json({ message: 'Failed to create health report' });
  }
};

exports.listReports = async (req, res) => {
  try {
    const { q, category, status, from, to, schedule, type } = req.query;
    const filter = {};
    if (q) {
      const regex = { $regex: q, $options: 'i' };
      filter.$or = [
        { title: regex },
        { reportType: regex },
        { description: regex },
        { generatedBy: regex },
        { tags: regex }
      ];
    }
    if (category && category !== 'all') {
      filter.category = category;
    }
    if (type) {
      filter.reportType = type;
    }
    if (status && status !== 'all') {
      filter.status = status;
    }
    if (schedule === 'true') {
      filter['schedule.enabled'] = true;
    }
    if (from || to) {
      filter['dateRange.start'] = {};
      if (from) {
        filter['dateRange.start'].$gte = toDate(from);
      }
      if (to) {
        filter['dateRange.start'].$lte = toDate(to);
      }
    }
    const reports = await HealthReport.find(filter).sort({ generatedAt: -1, createdAt: -1 }).lean();
    const totals = await HealthReport.countDocuments(filter);
    return res.json({ items: reports, total: totals });
  } catch (error) {
    console.error('listReports error', error);
    return res.status(500).json({ message: 'Failed to list health reports' });
  }
};

exports.getReport = async (req, res) => {
  try {
    const report = await HealthReport.findById(req.params.id).lean();
    if (!report) {
      return res.status(404).json({ message: 'Report not found' });
    }
    return res.json(report);
  } catch (error) {
    console.error('getReport error', error);
    return res.status(500).json({ message: 'Failed to get health report' });
  }
};

exports.updateReport = async (req, res) => {
  try {
    const payload = buildPayload(req.body || {}, req.user);
    if (Object.keys(payload).length === 0) {
      return res.status(400).json({ message: 'No updates provided' });
    }
    payload.updatedBy = req.user?.id || null;
    const report = await HealthReport.findByIdAndUpdate(
      req.params.id,
      payload,
      { new: true, runValidators: true }
    );
    if (!report) {
      return res.status(404).json({ message: 'Report not found' });
    }
    return res.json(report);
  } catch (error) {
    console.error('updateReport error', error);
    return res.status(500).json({ message: 'Failed to update health report' });
  }
};

exports.deleteReport = async (req, res) => {
  try {
    const report = await HealthReport.findByIdAndDelete(req.params.id);
    if (!report) {
      return res.status(404).json({ message: 'Report not found' });
    }
    return res.json({ success: true });
  } catch (error) {
    console.error('deleteReport error', error);
    return res.status(500).json({ message: 'Failed to delete health report' });
  }
};

exports.getReportStats = async (req, res) => {
  try {
    const now = new Date();
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    const [totalReports, monthReports, scheduledReports, completedReports, grouped] = await Promise.all([
      HealthReport.countDocuments(),
      HealthReport.countDocuments({ generatedAt: { $gte: startOfMonth } }),
      HealthReport.countDocuments({ $or: [{ status: 'scheduled' }, { 'schedule.enabled': true }] }),
      HealthReport.countDocuments({ status: 'completed' }),
      HealthReport.aggregate([
        { $group: { _id: '$category', count: { $sum: 1 } } }
      ])
    ]);
    const categoryCounts = grouped.reduce((acc, item) => {
      const key = item?._id || 'uncategorized';
      acc[key] = item?.count || 0;
      return acc;
    }, {});
    const complianceRate = totalReports === 0 ? 0 : Math.round((completedReports / totalReports) * 100);
    return res.json({
      totalReports,
      monthReports,
      scheduledReports,
      complianceRate,
      categoryCounts
    });
  } catch (error) {
    console.error('getReportStats error', error);
    return res.status(500).json({ message: 'Failed to get report statistics' });
  }
};
